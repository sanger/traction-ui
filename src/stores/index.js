import config from '@/api/Config.js'
import build from '@/api/ApiBuilder.js'
import PlateMap from '@/config/PlateMap.json'
import { defineStore } from 'pinia'
import { handleResponse } from '@/api/ResponseHelper.js'
import { dataToObjectById, extractAttributes } from '@/api/JsonApi.js'

export const errorFor = ({ lines, records }, message) =>
  `Library ${records} on line ${lines}: ${message}`

const useRootStore = defineStore('root', {
  state: () => ({
    //Build an API instance using the config
    // api: mergeApis(build({ config })),
    api: build({ config }),

    //Get plateMap state from the PlateMap.json file
    plateMap: PlateMap,

    /*Messages to be printed to the user in the front end
     * The messages are stored in an object with a unique id as the key
     * and the message as the value
     */
    messages: {},
    /*
     * tagSets: A dictionary of tagSets fetched from the service
     */
    tagSets: {},

    /*
     * libraryTypes: An array of library types fetched from the service
     */
    libraryTypes: [],
  }),
  getters: {
    tagSetsArray: (state) => Object.values(state.tagSets),
  },
  actions: {
    /**
     * Asynchronously sets tagSets in store using tagSets fetched from service (/traction/tag_sets).
     */
    async fetchTagSets(pipeline = 'pacbio') {
      if (!['ont', 'pacbio'].includes(pipeline)) {
        return { success: false, errors: [`Tag sets cannot be retrieved for pipeline ${pipeline}`] }
      }
      const request = this.api.traction[pipeline].tag_sets
      const promise = request.get()
      const {
        success,
        body: { data },
        errors = [],
      } = await handleResponse(promise)

      if (success && data) {
        this.tagSets = dataToObjectById({ data })
      }
      return { success, errors }
    },

    /**
     * Adds a message to the store with a unique id as the key which is the last message id + 1
     * @param {*} message The message to be added
     */
    addMessage(message) {
      //Remove the last message and return its id
      const messageId = Object.keys(this.messages).pop() ?? 0
      this.messages[messageId + 1] = message
    },
    /**
     * Removes a message from the store by its index
     * @param {*} messageIndex index of the message to be removed
     */
    removeMessage(messageIndex) {
      delete this.messages[messageIndex]
    },

    /**
     * Clears all messages
     */
    clearMessages() {
      this.messages = {}
    },

    /**
     * Adds a CSV log message with the given information, error, and type.
     * The type defaults to 'danger' if not provided.
     * The message is generated by calling `errorFor` with the provided information and error.
     * The message is added with root set to true.
     *
     * @param {string} info - The information for the message.
     * @param {string} error - The error for the message.
     * @param {string} [type='danger'] - The type of the message (optional, defaults to 'danger').
     *
     * @example
     * // Add a CSV message
     * addCSVMessage('info123', 'error123');
     */
    addCSVLogMessage(info, error, type = 'danger') {
      this.addMessage({ type, message: errorFor(info, error) }, { root: true })
    },

    /**
     * Fetches library types from the API and updates the store state.
     *
     * @async
     * @returns {Object} An object containing:
     *   - success {boolean}: Whether the API request was successful.
     *   - errors {Array}: Any errors returned from the API.
     *
     * @description
     * This action sends a GET request to the library types API endpoint.
     * If the request is successful, it transforms the returned library type data into an object keyed by ID
     * using `dataToObjectById` and updates the store's `resources.libraryTypes` state.
     * This allows efficient lookup and management of library types within the application.
     * The function returns an object with the success status and any errors encountered during the request.
     *
     * @example
     * const { success, errors } = await fetchLibraryTypes()
     * if (success) {
     *   // Access library types via store.resources.libraryTypes
     * }
     */
    async fetchLibraryTypes() {
      const request = this.api.traction.library_types
      const promise = request.get()
      const {
        success,
        body: { data },
        errors = [],
      } = await handleResponse(promise)

      if (success && data) {
        this.libraryTypes = data.map(extractAttributes)
      }

      return { success, errors }
    },
  },
})

export default useRootStore
