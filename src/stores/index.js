import config from '@/api/Config.js'
import buildV2 from '@/api/v2/ApiBuilder.js'
import PlateMap from '@/config/PlateMap.json'
import { defineStore } from 'pinia'
import { handleResponse } from '@/api/v2/ResponseHelper.js'
import { dataToObjectById } from '@/api/JsonApi.js'
import store from '@/store'

export const errorFor = ({ lines, records }, message) =>
  `Library ${records} on line ${lines}: ${message}`

const useRootStore = defineStore('root', {
  state: () => ({
    //Build an API instance using the config
    // api: mergeApis(build({ config })),
    api: {
      v2: buildV2({ config }),
    },

    //Get plateMap state from the PlateMap.json file
    plateMap: PlateMap,

    /*Messages to be printed to the user in the front end
     * The messages are stored in an object with a unique id as the key
     * and the message as the value
     */
    messages: {},
    /*
     * tagSets: A dictionary of tagSets fetched from the service
     */
    tagSets: {},
  }),
  getters: {
    tagSetsArray: (state) => Object.values(state.tagSets),
  },
  actions: {
    /**
     * Asynchronously sets tagSets in store using tagSets fetched from service (/traction/tag_sets).
     */
    async fetchTagSets(pipeline = 'pacbio') {
      if (!['ont', 'pacbio'].includes(pipeline)) {
        return { success: false, errors: [`Tag sets cannot be retrieved for pipeline ${pipeline}`] }
      }
      const request = this.api.v2.traction[pipeline].tag_sets
      const promise = request.get()
      const {
        success,
        body: { data },
        errors = [],
      } = await handleResponse(promise)

      if (success && data) {
        this.tagSets = dataToObjectById({ data })
      }
      return { success, errors }
    },

    /**
     * Adds a message to the store with a unique id as the key which is the last message id + 1
     * @param {*} message The message to be added
     */
    addMessage(message) {
      //Remove the last message and return its id
      const messageId = Object.keys(this.messages).pop() ?? 0
      this.messages[messageId + 1] = message
    },
    /**
     * Removes a message from the store by its index
     * @param {*} messageIndex index of the message to be removed
     */
    removeMessage(messageIndex) {
      delete this.messages[messageIndex]
    },

    /**
     * Clears all messages
     */
    clearMessages() {
      this.messages = {}
    },

    //TODO: This need to be removed once we converted all stores to Pinia
    addVuexMessage({ type, message }) {
      store.commit('traction/addMessage', { type, message })
    },

    /**
     * Adds a CSV log message with the given information, error, and type.
     * The type defaults to 'danger' if not provided.
     * The message is generated by calling `errorFor` with the provided information and error.
     * The message is added with root set to true.
     *
     * @param {string} info - The information for the message.
     * @param {string} error - The error for the message.
     * @param {string} [type='danger'] - The type of the message (optional, defaults to 'danger').
     *
     * @example
     * // Add a CSV message
     * addCSVMessage('info123', 'error123');
     */
    addCSVLogMessage(info, error, type = 'danger') {
      this.addMessage({ type, message: errorFor(info, error) }, { root: true })
      //TODO: This need to be removed once we converted all stores to Pinia
      this.addVuexMessage({ type, message: errorFor(info, error) })
    },
  },
})

export default useRootStore
